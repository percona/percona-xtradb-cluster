# connection node_2 : starting async slave
START SLAVE USER='root';
Warnings:
Note	1759	Sending passwords in plain text without SSL/TLS is extremely insecure.
#
# Test preparation
#
# connection node_1
CREATE DATABASE db;
USE db;
CREATE TABLE db.counter(id INT PRIMARY KEY AUTO_INCREMENT, count INT);
# connection node_1
CREATE DATABASE dbx;
# connection node_2
CREATE DATABASE dbx;
#
# Test async.db.ddl.1.1 : CREATE DATABASE
#
# connection node_1
USE db;
CREATE DATABASE db1;
INSERT INTO db.counter(count) VALUES(1);
include/assert.inc ["db1 is on node_1"]
# connection node_2
include/assert.inc ["db1 is on node_2"]
# connection node_3
include/assert.inc ["db1 is on node_3"]
#
# Test async.db.ddl.1.2 : ALTER DATABASE
#
# connection node_1
USE db;
ALTER database db1 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(2);
include/assert.inc ['db1 was altered on node 1']
# connection node_2
include/assert.inc ['db1 was altered on node 2']
# connection node_3
include/assert.inc ['db1 was altered on node 3']
# connection node_1
USE db1;
ALTER database db1 CHARACTER SET = 'utf8mb4';
#
# Test async.db.ddl.1.3 : DROP DATABASE
#
# connection node_1
USE db;
DROP database db1;
INSERT INTO db.counter(count) VALUES(3);
include/assert.inc ['db1 is not on node_1']
# connection node_2
include/assert.inc ['db1 is not on node_2']
# connection node_3
include/assert.inc ['db1 is not on node_3']
#
# Test async.db.ddl.2.1 : CREATE DATABASE
#
# connection node_1
USE db;
CREATE DATABASE dbx2;
INSERT INTO db.counter(count) VALUES(4);
include/assert.inc ['dbx2 is on node_1']
# connection node_2
include/assert.inc ['dbx2 is not on node_2']
# connection node_3
include/assert.inc ['dbx2 is not on node_3']
#
# Test preparation for async.db.ddl.2.2
#
# connection node_2
USE db;
CREATE DATABASE dbx2;
# connection node_3
include/assert.inc ['dbx2 is on node_3']
#
# Test async.db.ddl.2.2 : ALTER DATABASE
#
# connection node_1
USE db;
ALTER DATABASE dbx2 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(5);
include/assert.inc ['dbx2 was altered on node 1']
# connection node_2
include/assert.inc ['dbx2 was not altered on node 2']
# connection node_3
include/assert.inc ['dbx2 was not altered on node 3']
# connection node_1
USE db;
ALTER database dbx2 CHARACTER SET = 'utf8mb4';
#
# Test async.db.ddl.2.3 : DROP DATABASE
#
# connection node_1
USE db;
DROP database dbx2;
INSERT INTO db.counter(count) VALUES(6);
include/assert.inc ['dbx2 is not on node_1']
# connection node_2
include/assert.inc ['dbx2 is on node_2']
# connection node_3
include/assert.inc ['dbx2 is on node_3']
# Test async.db.ddl.2 cleanup
# connection node_2
DROP DATABASE dbx2;
# connection node_3
include/assert.inc ['dbx2 is not on node_3']
#
# Test async.db.ddl.3.1 : CREATE DATABASE
#
# connection node_1
USE dbx;
CREATE DATABASE db1;
INSERT INTO db.counter(count) VALUES(7);
include/assert.inc ['db1 is on node_1']
# connection node_2
include/assert.inc ['db1 is on node_2']
# connection node_3
include/assert.inc ['db1 is on node_3']
#
# Test async.db.ddl.3.2 : ALTER DATABASE
#
# connection node_1
USE dbx;
ALTER database db1 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(8);
include/assert.inc ['db1 was altered on node 1']
# connection node_2
include/assert.inc ['db1 was altered on node 2']
# connection node_3
include/assert.inc ['db1 was altered on node 3']
# connection node_1
USE db1;
ALTER database db1 CHARACTER SET = 'utf8mb4';
#
# Test async.db.ddl.3.3 : DROP DATABASE
#
# connection node_1
USE dbx;
DROP DATABASE db1;
INSERT INTO db.counter(count) VALUES(9);
include/assert.inc ['db1 is not on node_1']
# connection node_2
include/assert.inc ['db1 is not on node_2']
# connection node_3
include/assert.inc ['db1 is not on node_3']
#
# Test async.db.ddl.4.1 : CREATE DATABASE
#
# connection node_1
USE dbx;
CREATE DATABASE dbx2;
INSERT INTO db.counter(count) VALUES(10);
include/assert.inc ['dbx2 is on node_1']
# connection node_2
include/assert.inc ['dbx2 is not on node_2']
# connection node_3
include/assert.inc ['dbx2 is not on node_3']
# prepare for next tests
# connection node_2
CREATE DATABASE dbx2;
# connection node_3
include/assert.inc ["dbx2 is on node_3"]
#
# Test async.db.ddl.4.2 : ALTER DATABASE
#
# connection node_1
USE dbx;
ALTER database dbx2 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(11);
include/assert.inc ['dbx2 was altered on node 1']
# connection node_2
include/assert.inc ['dbx2 was not altered on node 2']
# connection node_3
include/assert.inc ['dbx2 was not altered on node 3']
# connection node_1
USE dbx;
ALTER database dbx2 CHARACTER SET = 'utf8mb4';
#
# Test async.db.ddl.4.3 : DROP DATABASE
#
# connection node_1
USE dbx;
DROP DATABASE dbx2;
INSERT INTO db.counter(count) VALUES(12);
include/assert.inc ['dbx2 is not on node_1']
# connection node_2
include/assert.inc ['dbx2 is on node_2']
# connection node_3
include/assert.inc ['dbx2 is on node_3']
#
# Test async.db.ddl.4 cleanup
#
# connection node_1
include/assert.inc ['dbx2 is not on node_1']
# connection node_2
DROP DATABASE dbx2;
# connection node_3
include/assert.inc ['dbx2 is not on node_3']
#
# async.tbl.ddl test preparation
#
# connection node_1
CREATE DATABASE db1;
CREATE DATABASE dbx1;
# connection node_3
include/assert.inc ["db1 is on node_3"]
CREATE DATABASE dbx1;
# connection node_2
include/assert.inc ["db1 is on node_2"]
include/assert.inc ["dbx1 is on node_2"]
#
# Test async.tbl.ddl.1.1 : CREATE TABLE
#
# connection node_1
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
INSERT INTO db.counter(count) VALUES(13);
# connection node_2
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# Test async.tbl.ddl.1.2 : ALTER TABLE
#
# connection node_1
USE db;
ALTER TABLE db1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(14);
# connection node_2
include/assert.inc ['t1.x3 is on node_2']
# connection node_3
include/assert.inc ['t1.x3 is on node_3']
#
# Test async.tbl.ddl.1.3 : RENAME TABLE
#
# connection node_1
USE db;
RENAME TABLE db1.t1 TO db1.t2;
INSERT INTO db.counter(count) VALUES(15);
# connection node_2
include/assert.inc ['t1 is not on node_2']
include/assert.inc ['t2 is on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
include/assert.inc ['t2 is on node_3']
#
# async.tbl.ddl.1.4 test preparation
#
# connection node_1
USE db;
INSERT INTO db1.t2(id) VALUES(1);
# connection node_3
include/assert.inc ["db1.t2 has a row"]
# connection node_2
include/assert.inc ["db1.t2 has a row"]
#
# Test async.tbl.ddl.1.4 : TRUNCATE TABLE
#
# connection node_1
USE db;
TRUNCATE TABLE db1.t2;
INSERT INTO db.counter(count) VALUES(16);
# connection node_2
include/assert.inc ['db1.t2 is truncated on node_2']
# connection node_3
include/assert.inc ['db1.t2 is truncated on node_3']
#
# Test async.tbl.ddl.1.5 : DROP TABLE
#
# connection node_1
USE db;
DROP TABLE db1.t2;
INSERT INTO db.counter(count) VALUES(17);
# connection node_2
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t2 is not on node_3']
#
# Test async.tbl.ddl.2.1 : CREATE TABLE
#
# connection node_1
USE db;
CREATE TABLE dbx1.t1(id INT PRIMARY KEY);
INSERT INTO db.counter(count) VALUES(18);
# connection node_2
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# Test async.tbl.ddl.2.2 : ALTER TABLE
#
# connection node_1
USE db;
ALTER TABLE dbx1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(19);
# connection node_2
include/assert.inc ['t1.x3 is on node_2']
# connection node_3
include/assert.inc ['t1.x3 is on node_3']
#
# Test async.tbl.ddl.2.3 : RENAME TABLE
#
# connection node_1
USE db;
RENAME TABLE dbx1.t1 TO dbx1.t2;
INSERT INTO db.counter(count) VALUES(20);
# connection node_2
include/assert.inc ['t1 is not on node_2']
include/assert.inc ['t2 is on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
include/assert.inc ['t2 is on node_3']
#
# Test preparation for async.tbl.ddl.2.4
#
# connection node_2
INSERT INTO dbx1.t2(id) VALUES(99);
# connection node_3
#
# Test async.tbl.ddl.2.4 : TRUNCATE TABLE
#
# connection node_1
USE db;
TRUNCATE TABLE dbx1.t2;
INSERT INTO db.counter(count) VALUES(21);
# connection node_2
include/assert.inc ['dbx1.t2 is truncated on node_2']
# connection node_3
include/assert.inc ['dbx1.t2 is truncated on node_3']
#
# Test async.tbl.ddl.2.5 : DROP TABLE
#
# connection node_1
USE db;
DROP TABLE dbx1.t2;
INSERT INTO db.counter(count) VALUES(22);
# connection node_2
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t2 is not on node_3']
#
# Test async.tbl.ddl.3.1 : CREATE TABLE
#
# connection node_1
USE dbx;
CREATE TABLE db1.t1(id INT PRIMARY KEY);
INSERT INTO db.counter(count) VALUES(23);
# connection node_2
include/assert.inc ['t1 is not on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
#
# Test preparation
#
# connection node_1
USE dbx;
DROP TABLE db1.t1;
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY);
# connection node_3
include/assert.inc ["t1 is on node_3"]
# connection node_2
include/assert.inc ["t1 is on node_2"]
#
# Test async.tbl.ddl.3.2 : ALTER TABLE
#
# connection node_1
USE dbx;
ALTER TABLE db1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(24);
# connection node_2
include/assert.inc ['t1.x3 is not on node_2']
# connection node_3
include/assert.inc ['t1.x3 is not on node_3']
#
# Test async.tbl.ddl.3.3 : RENAME TABLE
#
# connection node_1
USE dbx;
RENAME TABLE db1.t1 TO db1.t2;
INSERT INTO db.counter(count) VALUES(25);
# connection node_2
include/assert.inc ['t1 is on node_2']
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
include/assert.inc ['t2 is not on node_3']
# restore table to original name
# connection node_1
USE dbx;
RENAME TABLE db1.t2 TO db1.t1;
#
# Test preparation for async.tbl.ddl.3.4
#
# connection node_1
USE db;
INSERT INTO db1.t1(id) VALUES(99);
# connection node_3
include/assert.inc ["Row added to db1.t1 on node_3"]
# connection node_2
include/assert.inc ["Row added to db1.t1 on node_2"]
#
# Test async.tbl.ddl.3.4 : TRUNCATE TABLE
#
# connection node_1
USE dbx;
TRUNCATE TABLE db1.t1;
INSERT INTO db.counter(count) VALUES(26);
# connection node_2
include/assert.inc ['db1.t1 is not truncated on node_2']
# connection node_3
include/assert.inc ['db1.t1 is not truncated on node_3']
#
# Test async.tbl.ddl.3.5 : DROP TABLE
#
# connection node_1
USE dbx;
DROP TABLE db1.t1;
INSERT INTO db.counter(count) VALUES(27);
# connection node_2
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# async.tbl.ddl.3.5 test cleanup
#
# connection node_2
DROP TABLE db1.t1;
# connection node_3
include/assert.inc ['t1 is not on node_3']
#
# Test async.tbl.ddl.4.1 : CREATE TABLE
#
# connection node_1
USE dbx;
CREATE TABLE dbx1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
INSERT INTO db.counter(count) VALUES(28);
# connection node_2
include/assert.inc ['t1 is not on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
#
# Test preparation for async.tbl.ddl.4.2
#
# connection node_1
USE dbx;
DROP TABLE dbx1.t1;
USE db;
CREATE TABLE dbx1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
# connection node_3
include/assert.inc ["t1 is on node_3"]
# connection node_2
include/assert.inc ["t1 is on node_2"]
#
# Test async.tbl.ddl.4.2 : ALTER TABLE
#
# connection node_1
USE dbx;
ALTER TABLE dbx1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(29);
# connection node_2
include/assert.inc ['t1.x3 is not on node_2']
# connection node_3
include/assert.inc ['t1.x3 is not on node_3']
#
# Test async.tbl.ddl.4.3 : RENAME TABLE
#
# connection node_1
USE dbx;
RENAME TABLE dbx1.t1 TO dbx1.t2;
INSERT INTO db.counter(count) VALUES(30);
# connection node_2
include/assert.inc ['t1 is on node_2']
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
include/assert.inc ['t2 is not on node_3']
# restore table to original name
# connection node_1
USE dbx;
RENAME TABLE dbx1.t2 TO dbx1.t1;
#
# Test preparation for async.tbl.ddl.4.4
#
# connection node_1
INSERT INTO dbx1.t1(id) VALUES(99);
# connection node_2
INSERT INTO dbx1.t1(id) VALUES(99);
# connection node_3
#
# Test async.tbl.ddl.4.4 : TRUNCATE TABLE
#
# connection node_1
USE dbx;
TRUNCATE TABLE dbx1.t1;
INSERT INTO db.counter(count) VALUES(31);
# connection node_2
include/assert.inc ['dbx1.t1 is not truncated on node_2']
# connection node_3
include/assert.inc ['dbx1.t1 is not truncated on node_3']
#
# Test async.tbl.ddl.4.5 : DROP TABLE
#
# connection node_1
USE dbx;
DROP TABLE dbx1.t1;
INSERT INTO db.counter(count) VALUES(32);
# connection node_2
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# Test cleanup
#
# connection node_2
DROP TABLE dbx1.t1;
# connection node_3
include/assert.inc ['t1 is not on node_3']
#
# async.tbl.ddl test cleanup
#
# connection node_1
DROP DATABASE db1;
DROP DATABASE dbx1;
# connection node_3
include/assert.inc ["db1 is not on node_3"]
DROP DATABASE dbx1;
# connection node_2
include/assert.inc ["db1 is not on node_2"]
include/assert.inc ["dbx1 is not on node_2"]
#
# async.tbl.dml test preparation
#
# connection node_1
CREATE DATABASE db1;
CREATE DATABASE dbx1;
# connection node_3
include/assert.inc ['db1 is on node_3']
CREATE DATABASE dbx1;
# connection node_2
include/assert.inc ['db1 is on node_2']
include/assert.inc ['dbx1 is on node_2']
# connection node_1
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
USE db;
CREATE TABLE dbx1.t2(id INT PRIMARY KEY, f2 LONGBLOB);
# connection node_3
include/assert.inc ["db1.t1 is on node_3"]
include/assert.inc ["dbx1.t2 is on node_3"]
# connection node_2
include/assert.inc ["db1.t1 is on node_2"]
include/assert.inc ["dbx1.t2 is on node_2"]
#
# Test async.tbl.dml.1.1 : INSERT
#
# connection node_1
USE db;
INSERT INTO db1.t1(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(33);
# connection node_2
include/assert.inc ["Insert succeeded on node_2"]
# connection node_3
include/assert.inc ["Insert succeeded on node_3"]
#
# Test async.tbl.dml.1.2 : UPDATE
#
# connection node_1
USE db;
UPDATE db1.t1 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(34);
# connection node_2
include/assert.inc ["Update succeeded on node_2"]
# connection node_3
include/assert.inc ["Update succeeded on node_3"]
#
# Test async.tbl.dml.1.3 : DELETE
#
# connection node_1
USE db;
DELETE FROM db1.t1 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(35);
# connection node_2
include/assert.inc ["Delete succeeded on node_2"]
# connection node_3
include/assert.inc ["Delete succeeded on node_3"]
#
# Testcase async.tbl.dml.1 cleanup
#
# connection node_1
USE db;
TRUNCATE TABLE db1.t1;
#
# Test async.tbl.dml.2.1 : INSERT
#
# connection node_1
USE db;
INSERT INTO dbx1.t2(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(36);
# connection node_2
include/assert.inc ["Insert not replicated to node_2"]
# connection node_3
include/assert.inc ["Insert not replicated to node_3"]
#
# Test async.tbl.dml.2 test preparation
#
# connection node_2
INSERT INTO dbx1.t2(id) VALUES(1);
# connection node_3
#
# Test async.tbl.dml.2.2 : UPDATE
#
# connection node_1
USE db;
UPDATE dbx1.t2 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(37);
# connection node_2
include/assert.inc ["Update not replicated to node_2"]
# connection node_3
include/assert.inc ["Update not replicated to node_3"]
#
# Test async.tbl.dml.2.3 : DELETE
#
# connection node_1
USE db;
DELETE FROM dbx1.t2 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(38);
# connection node_2
include/assert.inc ["Delete not replicated to node_2"]
# connection node_3
include/assert.inc ["Delete not replicated to node_3"]
#
# Testcase async.tbl.dml.2.3 cleanup
#
# connection node_2
USE db;
TRUNCATE TABLE dbx1.t2;
# connection node_3
USE db;
TRUNCATE TABLE dbx1.t2;
#
# Test async.tbl.dml.3.1 : INSERT
#
# connection node_1
USE dbx;
INSERT INTO db1.t1(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(39);
# connection node_2
include/assert.inc ["Insert replicated to node_2"]
# connection node_3
include/assert.inc ["Insert replicated to node_3"]
#
# Test async.tbl.dml.3.2 : UPDATE
#
# connection node_1
USE dbx;
UPDATE db1.t1 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(40);
# connection node_2
include/assert.inc ["Update replicated to node_2"]
# connection node_3
include/assert.inc ["Update replicated to node_3"]
#
# Test async.tbl.dml.3.3 : DELETE
#
# connection node_1
USE dbx;
DELETE FROM db1.t1 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(41);
# connection node_2
include/assert.inc ["Delete replicated to node_2"]
# connection node_3
include/assert.inc ["Delete replicated to node_3"]
#
# Test async.tbl.dml.4.1 : INSERT
#
# connection node_1
USE dbx;
INSERT INTO dbx1.t2(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(42);
# connection node_2
include/assert.inc ["Insert not replicated to node_2"]
# connection node_3
include/assert.inc ["Insert not replicated to node_3"]
#
# Test async.tbl.dml.4 test preparation
#
# connection node_2
INSERT INTO dbx1.t2(id) VALUES(1);
# connection node_3
#
# Test async.tbl.dml.4.2 : UPDATE
#
# connection node_1
USE dbx;
UPDATE dbx1.t2 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(43);
# connection node_2
include/assert.inc ["Update not replicated to node_2"]
# connection node_3
include/assert.inc ["Update not replicated to node_3"]
#
# Test async.tbl.dml.4.3 : DELETE
#
# connection node_1
USE dbx;
DELETE FROM dbx1.t2 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(44);
# connection node_2
include/assert.inc ["Delete not replicated to node_2"]
# connection node_3
include/assert.inc ["Delete not replicated to node_3"]
#
# Testcase async.tbl.dml.4.3 cleanup
#
# connection node_2
USE db;
TRUNCATE TABLE dbx1.t2;
# connection node_3
USE db;
TRUNCATE TABLE dbx1.t2;
#
# async.tbl.dml test cleanup
#
# connection node_1
DROP DATABASE db1;
DROP DATABASE dbx1;
# connection node_2
include/assert.inc ['db1 is not on node_2']
DROP DATABASE dbx1;
# connection node_3
include/assert.inc ['db1 is not on node_3']
include/assert.inc ['dbx1 is not on node_3']
#
# async.acct.mgmt test preparation
#
# connection node_1
CREATE DATABASE db1;
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
# connection node_3
include/assert.inc ['db1.t1 is on node_3']
# connection node_2
include/assert.inc ['db1.t1 is on node_2']
#
# Test async.acct.mgmt.1.1 : CREATE USER
#
# connection node_1
USE db;
CREATE USER "foo"@"%" IDENTIFIED BY "bar";
INSERT INTO db.counter(count) VALUES(45);
# connection node_2
include/assert.inc ["User foo is on node_2"]
# connection node_3
include/assert.inc ["User foo is on node_3"]
#
# Test async.acct.mgmt.1.2 : CHANGE PASSWORD
#
# connection node_1
USE db;
SET PASSWORD FOR "foo"@"%" = "notapassword";
INSERT INTO db.counter(count) VALUES(46);
include/assert.inc ["User foo is altered on node_1"]
# connection node_2
include/assert.inc ["User foo is altered on node_2"]
# connection node_3
include/assert.inc ["User foo is altered on node_3"]
#
# Test async.acct.mgmt.1.3 : ALTER USER
#
# connection node_1
include/assert.inc ["User foo is not expired on node_1"]
USE db;
ALTER USER "foo"@"%" PASSWORD EXPIRE;
include/assert.inc ["User foo is altered on node_1"]
INSERT INTO db.counter(count) VALUES(47);
# connection node_2
include/assert.inc ["User foo is altered on node_2"]
# connection node_3
include/assert.inc ["User foo is altered on node_3"]
#
# Test async.acct.mgmt.1.4 : GRANT
#
# connection node_1
USE db;
GRANT SELECT ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(48);
include/assert.inc ["User foo has SELECT access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo has SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has SELECT access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.1.5 : REVOKE
#
# connection node_1
USE db;
REVOKE SELECT ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(49);
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.1.6 : GRANT ALL
#
# connection node_1
USE db;
GRANT ALL ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(50);
include/assert.inc ["User foo has ALL access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo has ALL access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has ALL access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.1.7 : REVOKE ALL
#
# connection node_1
USE db;
REVOKE ALL ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(51);
include/assert.inc ["User foo has no access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo has no access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has no access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.1.8 : DROP USER
#
# connection node_1
USE db;
DROP USER "foo"@"%";
INSERT INTO db.counter(count) VALUES(52);
# connection node_2
include/assert.inc ["User foo is not on node_2"]
# connection node_3
include/assert.inc ["User foo is not on node_3"]
#
# Test async.acct.mgmt.2.1 : CREATE USER
#
# connection node_1
USE dbx;
CREATE USER "foo"@"%" IDENTIFIED BY "bar";
INSERT INTO db.counter(count) VALUES(53);
include/assert.inc ["User foo is on node_1"]
# connection node_2
include/assert.inc ["User foo is not on node_2"]
# connection node_3
include/assert.inc ["User foo is not on node_3"]
#
# Test preparation for async.acct.mgmt.2
#
# connection node_2
USE db;
CREATE USER "foo"@"%" IDENTIFIED BY "bar";
include/assert.inc ["User foo is on node_2"]
# connection node_3
include/assert.inc ["User foo is on node_3"]
#
# Test async.acct.mgmt.2.2 : CHANGE PASSWORD
#
# connection node_1
USE dbx;
SET PASSWORD FOR "foo"@"%" = "notapassword";
INSERT INTO db.counter(count) VALUES(54);
include/assert.inc ["User foo is altered on node_1"]
# connection node_2
include/assert.inc ["User foo is not altered on node_2"]
# connection node_3
include/assert.inc ["User foo is not altered on node_3"]
#
# Test async.acct.mgmt.2.3 : ALTER USER
#
# connection node_1
include/assert.inc ["User foo is not expired on node_1"]
USE dbx;
ALTER USER "foo"@"%" PASSWORD EXPIRE;
include/assert.inc ["User foo is altered on node_1"]
INSERT INTO db.counter(count) VALUES(55);
# connection node_2
include/assert.inc ["User foo is not altered on node_2"]
# connection node_3
include/assert.inc ["User foo is not altered on node_3"]
#
# Test async.acct.mgmt.2.4 : GRANT
#
# connection node_1
USE dbx;
GRANT SELECT ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(56);
include/assert.inc ["User foo has SELECT access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_3"]
#
# Test preparation for async.acct.mgmt.2.5
#
# connection node_2
USE db;
GRANT SELECT ON db1.t1 TO "foo"@"%";
include/assert.inc ["User foo has SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has SELECT access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.2.5 : REVOKE
#
# connection node_1
USE dbx;
REVOKE SELECT ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(57);
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo has SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has SELECT access on db1.t1 on node_3"]
#
# Test cleanup for async.acct.mgmt.2.5
#
# connection node_2
USE db;
REVOKE SELECT ON db1.t1 FROM "foo"@"%";
# connection node_3
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.2.6 : GRANT ALL
#
# connection node_1
USE dbx;
GRANT ALL ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(58);
include/assert.inc ["User foo has ALL access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo does not have ALL access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo does not have ALL access on db1.t1 on node_3"]
#
# Test preparation for async.acct.mgmt.2.7
#
# connection node_2
USE db;
GRANT ALL ON db1.t1 TO "foo"@"%";
# connection node_3
include/assert.inc ["User foo has ALL access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.2.7 : REVOKE ALL
#
# connection node_1
USE dbx;
REVOKE ALL ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(59);
include/assert.inc ["User foo does not have access on db1.t1 on node_1"]
# connection node_2
include/assert.inc ["User foo has ALL access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has ALL access on db1.t1 on node_3"]
#
# Test async.acct.mgmt.2.8 : DROP USER
#
# connection node_1
USE dbx;
DROP USER "foo"@"%";
INSERT INTO db.counter(count) VALUES(60);
include/assert.inc ["User foo is not on node_1"]
# connection node_2
include/assert.inc ["User foo is on node_2"]
# connection node_3
include/assert.inc ["User foo is on node_3"]
#
# async.acct.mgmt test cleanup
#
# connection node_1
DROP DATABASE db1;
# connection node_3
include/assert.inc ['db1 is not on node_3']
USE db;
DROP USER "foo";
# connection node_2
include/assert.inc ['db1 is not on node_2']
include/assert.inc ["user foo is not on node_2"]
#
# Test galera.db.ddl.1.1 : CREATE DATABASE
#
# connection node_2
USE db;
CREATE DATABASE db1;
INSERT INTO db.counter(count) VALUES(61);
include/assert.inc ["db1 is on node_2"]
# connection node_3
include/assert.inc ["db1 is on node_3"]
#
# Test galera.db.ddl.1.2 : ALTER DATABASE
#
# connection node_2
USE db;
ALTER database db1 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(62);
include/assert.inc ['db1 was altered on node 2']
# connection node_3
include/assert.inc ['db1 was altered on node 3']
# connection node_2
USE db1;
ALTER database db1 CHARACTER SET = 'utf8mb4';
#
# Test galera.db.ddl.1.3 : DROP DATABASE
#
# connection node_2
USE db;
DROP database db1;
INSERT INTO db.counter(count) VALUES(63);
include/assert.inc ['db1 is not on node_2']
# connection node_3
include/assert.inc ['db1 is not on node_3']
#
# Test galera.db.ddl.2.1 : CREATE DATABASE
#
# connection node_2
USE db;
CREATE DATABASE dbx2;
INSERT INTO db.counter(count) VALUES(64);
include/assert.inc ['dbx2 is on node_2']
# connection node_3
include/assert.inc ['dbx2 is on node_3']
# connection node_2
DROP DATABASE dbx2;
#
# galera.db.ddl.2.2 test preparation
#
# connection node_2
CREATE DATABASE dbx2;
# connection node_3
# connection node_2
include/assert.inc ["dbx2 is on node_3"]
#
# Test galera.db.ddl.2.2 : DROP DATABASE
#
USE db;
DROP database dbx2;
INSERT INTO db.counter(count) VALUES(65);
include/assert.inc ['dbx2 is not on node_2']
# connection node_3
include/assert.inc ['dbx2 is not on node_3']
#
# Test preparation for galera.db.ddl.2.3
#
# connection node_2
CREATE DATABASE dbx2;
# connection node_3
include/assert.inc ['dbx2 is on node_3']
#
# Test galera.db.ddl.2.3 : ALTER DATABASE
#
# connection node_2
USE db;
ALTER DATABASE dbx2 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(66);
include/assert.inc ['dbx2 was altered on node 2']
# connection node_3
include/assert.inc ['dbx2 was altered on node 3']
# connection node_2
USE db;
ALTER database dbx2 CHARACTER SET = 'utf8mb4';
# Test galera.db.ddl.2 cleanup
# connection node_2
DROP DATABASE dbx2;
# connection node_3
#
# Test galera.db.ddl.3.1 : CREATE DATABASE
#
# connection node_2
USE dbx;
CREATE DATABASE db1;
INSERT INTO db.counter(count) VALUES(67);
include/assert.inc ['db1 is on node_2']
# connection node_3
include/assert.inc ['db1 is on node_3']
#
# Test galera.db.ddl.3.2 : ALTER DATABASE
#
# connection node_2
USE dbx;
ALTER database db1 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(68);
include/assert.inc ['db1 was altered on node 2']
# connection node_3
include/assert.inc ['db1 was altered on node 2']
# connection node_2
USE db1;
ALTER database db1 CHARACTER SET = 'utf8mb4';
#
# Test galera.db.ddl.3.3 : DROP DATABASE
#
# connection node_2
USE dbx;
DROP DATABASE db1;
INSERT INTO db.counter(count) VALUES(69);
include/assert.inc ['db1 is not on node_2']
# connection node_3
include/assert.inc ['db1 is not on node_3']
#
# Test galera.db.ddl.4.1 : CREATE DATABASE
#
# connection node_2
USE dbx;
CREATE DATABASE dbx2;
INSERT INTO db.counter(count) VALUES(70);
include/assert.inc ['dbx2 is on node_2']
# connection node_3
include/assert.inc ['dbx2 is on node_3']
#
# Test galera.db.ddl.4.2 : ALTER DATABASE
#
# connection node_2
USE dbx;
ALTER database dbx2 CHARACTER SET = "latin7";
INSERT INTO db.counter(count) VALUES(71);
include/assert.inc ['dbx2 was altered on node 2']
# connection node_3
include/assert.inc ['dbx2 was altered on node 3']
# connection node_2
USE dbx;
ALTER database dbx2 CHARACTER SET = 'utf8mb4';
#
# Test galera.db.ddl.4.3 : DROP DATABASE
#
# connection node_2
USE dbx;
DROP DATABASE dbx2;
INSERT INTO db.counter(count) VALUES(72);
include/assert.inc ['dbx2 is not on node_2']
# connection node_3
include/assert.inc ['dbx2 is not on node_3']
#
# galera.tbl.ddl test preparation
#
# connection node_2
CREATE DATABASE db1;
CREATE DATABASE dbx1;
# connection node_3
include/assert.inc ["db1 is on node_3"]
include/assert.inc ["dbx1 is on node_3"]
#
# Test galera.tbl.ddl.1.1 : CREATE TABLE
#
# connection node_2
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
INSERT INTO db1.t1(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(73);
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# Test galera.tbl.ddl.1.2 : ALTER TABLE
#
# connection node_2
USE db;
ALTER TABLE db1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(74);
include/assert.inc ['t1.x3 is on node_2']
# connection node_3
include/assert.inc ['t1.x3 is on node_3']
#
# Test galera.tbl.ddl.1.3 : RENAME TABLE
#
# connection node_2
USE db;
RENAME TABLE db1.t1 TO db1.t2;
INSERT INTO db.counter(count) VALUES(75);
include/assert.inc ['t1 is not on node_2']
include/assert.inc ['t2 is on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
include/assert.inc ['t2 is on node_3']
#
# Test galera.tbl.ddl.1.4 : TRUNCATE TABLE
#
# connection node_2
USE db;
TRUNCATE TABLE db1.t2;
INSERT INTO db.counter(count) VALUES(76);
include/assert.inc ['db1.t2 is truncated on node_2']
# connection node_3
include/assert.inc ['db1.t2 is truncated on node_3']
#
# Test galera.tbl.ddl.1.5 : DROP TABLE
#
# connection node_2
USE db;
DROP TABLE db1.t2;
INSERT INTO db.counter(count) VALUES(77);
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t2 is not on node_3']
#
# Test galera.tbl.ddl.2.1 : CREATE TABLE
#
# connection node_2
USE db;
CREATE TABLE dbx1.t1(id INT PRIMARY KEY);
INSERT INTO db.counter(count) VALUES(78);
include/assert.inc ['dbx1.t1 is on node_2']
# connection node_3
include/assert.inc ['dbx1.t1 is on node_3']
#
# Test galera.tbl.ddl.2.2 : ALTER TABLE
#
# connection node_2
USE db;
ALTER TABLE dbx1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(79);
include/assert.inc ['t1.x3 is on node_2']
# connection node_3
include/assert.inc ['t1.x3 is on node_3']
#
# Test galera.tbl.ddl.2.3 : RENAME TABLE
#
# connection node_2
USE db;
RENAME TABLE dbx1.t1 TO dbx1.t2;
INSERT INTO db.counter(count) VALUES(80);
include/assert.inc ['t1 is not on node_2']
include/assert.inc ['t2 is on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
include/assert.inc ['t2 is on node_3']
#
# Test preparation for galera.tbl.ddl.2.4
#
# connection node_2
INSERT INTO dbx1.t2(id) VALUES(99);
# connection node_3
#
# Test galera.tbl.ddl.2.4 : TRUNCATE TABLE
#
# connection node_2
USE db;
TRUNCATE TABLE dbx1.t2;
INSERT INTO db.counter(count) VALUES(81);
include/assert.inc ['dbx1.t2 is truncated on node_2']
# connection node_3
include/assert.inc ['dbx1.t2 is truncated on node_3']
#
# Test galera.tbl.ddl.2.5 : DROP TABLE
#
# connection node_2
USE db;
DROP TABLE dbx1.t2;
INSERT INTO db.counter(count) VALUES(82);
include/assert.inc ['dbx1.t2 is not on node_2']
# connection node_3
include/assert.inc ['dbx1.t2 is not on node_3']
#
# Test galera.tbl.ddl.3.1 : CREATE TABLE
#
# connection node_2
USE dbx;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
INSERT INTO db.counter(count) VALUES(83);
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# Test galera.tbl.ddl.3.2 : ALTER TABLE
#
# connection node_2
USE dbx;
ALTER TABLE db1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(84);
include/assert.inc ['t1.x3 is on node_2']
# connection node_3
include/assert.inc ['t1.x3 is on node_3']
#
# Test galera.tbl.ddl.3.3 : RENAME TABLE
#
# connection node_2
USE dbx;
RENAME TABLE db1.t1 TO db1.t2;
INSERT INTO db.counter(count) VALUES(85);
include/assert.inc ['t1 is not on node_2']
include/assert.inc ['t2 is on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
include/assert.inc ['t2 is on node_3']
#
# Test preparation for galera.tbl.ddl.3.4
#
# connection node_2
USE db;
INSERT INTO db1.t2(id) VALUES(99);
# connection node_3
include/assert.inc ["Row added to db1.t2 on node_3"]
#
# Test galera.tbl.ddl.3.4 : TRUNCATE TABLE
#
# connection node_2
USE dbx;
TRUNCATE TABLE db1.t2;
INSERT INTO db.counter(count) VALUES(86);
include/assert.inc ['db1.t2 is truncated on node_2']
# connection node_3
include/assert.inc ['db1.t2 is truncated on node_3']
#
# Test galera.tbl.ddl.3.5 : DROP TABLE
#
# connection node_2
USE dbx;
DROP TABLE db1.t2;
INSERT INTO db.counter(count) VALUES(87);
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t2 is not on node_3']
#
# Test galera.tbl.ddl.4.1 : CREATE TABLE
#
# connection node_2
USE dbx;
CREATE TABLE dbx1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
INSERT INTO db.counter(count) VALUES(88);
include/assert.inc ['t1 is on node_2']
# connection node_3
include/assert.inc ['t1 is on node_3']
#
# Test galera.tbl.ddl.4.2 : ALTER TABLE
#
# connection node_2
USE dbx;
ALTER TABLE dbx1.t1 ADD COLUMN x3 LONGBLOB;
INSERT INTO db.counter(count) VALUES(89);
include/assert.inc ['t1.x3 is on node_2']
# connection node_3
include/assert.inc ['t1.x3 is on node_3']
#
# Test galera.tbl.ddl.4.3 : RENAME TABLE
#
# connection node_2
USE dbx;
RENAME TABLE dbx1.t1 TO dbx1.t2;
INSERT INTO db.counter(count) VALUES(90);
include/assert.inc ['t1 is not on node_2']
include/assert.inc ['t2 is on node_2']
# connection node_3
include/assert.inc ['t1 is not on node_3']
include/assert.inc ['t2 is on node_3']
#
# Test preparation for galera.tbl.ddl.4.4
#
# connection node_2
INSERT INTO dbx1.t2(id) VALUES(99);
# connection node_3
#
# Test galera.tbl.ddl.4.4 : TRUNCATE TABLE
#
# connection node_2
USE dbx;
TRUNCATE TABLE dbx1.t2;
INSERT INTO db.counter(count) VALUES(91);
include/assert.inc ['dbx1.t2 is truncated on node_2']
# connection node_3
include/assert.inc ['dbx1.t2 is truncated on node_3']
#
# Test galera.tbl.ddl.4.5 : DROP TABLE
#
# connection node_2
USE dbx;
DROP TABLE dbx1.t2;
INSERT INTO db.counter(count) VALUES(92);
include/assert.inc ['t2 is not on node_2']
# connection node_3
include/assert.inc ['t2 is not on node_3']
#
# galera.tbl.ddl test cleanup
#
# connection node_2
DROP DATABASE db1;
DROP DATABASE dbx1;
# connection node_3
include/assert.inc ["db1 is not on node_3"]
include/assert.inc ["dbx1 is not on node_3"]
#
# galera.tbl.dml test preparation
#
# connection node_2
CREATE DATABASE db1;
CREATE DATABASE dbx1;
# connection node_3
include/assert.inc ['db1 is on node_3']
include/assert.inc ['dbx1 is on node_3']
# connection node_2
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
USE db;
CREATE TABLE dbx1.t2(id INT PRIMARY KEY, f2 LONGBLOB);
# connection node_3
include/assert.inc ["db1.t1 is on node_3"]
include/assert.inc ["dbx1.t2 is on node_3"]
#
# Test galera.tbl.dml.1.1 : INSERT
#
# connection node_2
USE db;
INSERT INTO db1.t1(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(93);
include/assert.inc ["Insert succeeded on node_2"]
# connection node_3
include/assert.inc ["Insert succeeded on node_3"]
#
# Test galera.tbl.dml.1.2 : UPDATE
#
# connection node_2
USE db;
UPDATE db1.t1 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(94);
include/assert.inc ["Update succeeded on node_2"]
# connection node_3
include/assert.inc ["Update succeeded on node_3"]
#
# Test galera.tbl.dml.1.3 : DELETE
#
# connection node_2
USE db;
DELETE FROM db1.t1 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(95);
include/assert.inc ["Delete succeeded on node_2"]
# connection node_3
include/assert.inc ["Delete succeeded on node_3"]
#
# Test galera.tbl.dml.2.1 : INSERT
#
# connection node_2
USE db;
INSERT INTO dbx1.t2(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(96);
include/assert.inc ["Insert succeeded on node_2"]
# connection node_3
include/assert.inc ["Insert replicated to node_3"]
#
# Test galera.tbl.dml.2 test preparation
#
# connection node_3
include/assert.inc ["Nodes 2 and 3 should be the same"]
#
# Test galera.tbl.dml.2.2 : UPDATE
#
# connection node_2
USE db;
UPDATE dbx1.t2 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(97);
include/assert.inc ["Update succeeded on node_2"]
# connection node_3
include/assert.inc ["Update replicated to node_3"]
#
# Test galera.tbl.dml.2.3 : DELETE
#
# connection node_2
USE db;
DELETE FROM dbx1.t2 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(98);
include/assert.inc ["Delete succeeded on node_2"]
# connection node_3
include/assert.inc ["Delete replicated to node_3"]
#
# Testcase galera.tbl.dml.2.3 cleanup
#
# connection node_2
USE db;
TRUNCATE TABLE dbx1.t2;
# connection node_3
USE db;
TRUNCATE TABLE dbx1.t2;
#
# Test galera.tbl.dml.3.1 : INSERT
#
# connection node_2
USE dbx;
INSERT INTO db1.t1(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(99);
include/assert.inc ["Insert replicated to node_2"]
# connection node_3
include/assert.inc ["Insert replicated to node_3"]
#
# Test galera.tbl.dml.3.2 : UPDATE
#
# connection node_2
USE dbx;
UPDATE db1.t1 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(100);
include/assert.inc ["Update succeeded on node_2"]
# connection node_3
include/assert.inc ["Update replicated to node_3"]
#
# Test galera.tbl.dml.3.3 : DELETE
#
# connection node_2
USE dbx;
DELETE FROM db1.t1 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(101);
include/assert.inc ["Delete succeeded on node_2"]
# connection node_3
include/assert.inc ["Delete replicated to node_3"]
#
# Test galera.tbl.dml.4.1 : INSERT
#
# connection node_2
USE dbx;
INSERT INTO dbx1.t2(id) VALUES(1);
INSERT INTO db.counter(count) VALUES(102);
include/assert.inc ["Insert succeeded on node_2"]
# connection node_3
include/assert.inc ["Insert replicated to node_3"]
#
# Test galera.tbl.dml.4 test preparation
#
# connection node_3
include/assert.inc ["node_2 and node_3 are the same"]
#
# Test galera.tbl.dml.4.2 : UPDATE
#
# connection node_2
USE dbx;
UPDATE dbx1.t2 SET f2 = "abcde" WHERE id = 1;
INSERT INTO db.counter(count) VALUES(103);
include/assert.inc ["Update succeeded on node_2"]
# connection node_3
include/assert.inc ["Update replicated to node_3"]
#
# Test galera.tbl.dml.4.3 : DELETE
#
# connection node_2
USE dbx;
DELETE FROM dbx1.t2 WHERE id = 1;
INSERT INTO db.counter(count) VALUES(104);
include/assert.inc ["Delete succeeded on node_2"]
# connection node_3
include/assert.inc ["Delete replicated to node_3"]
#
# Testcase galera.tbl.dml.4.3 cleanup
#
# connection node_2
USE db;
TRUNCATE TABLE dbx1.t2;
# connection node_3
USE db;
TRUNCATE TABLE dbx1.t2;
#
# galera.tbl.dml test cleanup
#
# connection node_2
DROP DATABASE db1;
DROP DATABASE dbx1;
# connection node_3
include/assert.inc ['db1 is not on node_3']
include/assert.inc ['dbx1 is not on node_3']
#
# galera.acct.mgmt test preparation
#
# connection node_2
CREATE DATABASE db1;
USE db;
CREATE TABLE db1.t1(id INT PRIMARY KEY, f2 LONGBLOB);
# connection node_3
include/assert.inc ['db1.t1 is on node_3']
#
# Test galera.acct.mgmt.1.1 : CREATE USER
#
# connection node_2
USE db;
CREATE USER "foo"@"%" IDENTIFIED BY "bar";
INSERT INTO db.counter(count) VALUES(105);
include/assert.inc ["User foo is on node_2"]
# connection node_3
include/assert.inc ["User foo is on node_3"]
#
# Test galera.acct.mgmt.1.2 : CHANGE PASSWORD
#
# connection node_2
USE db;
SET PASSWORD FOR "foo"@"%" = "notapassword";
INSERT INTO db.counter(count) VALUES(106);
include/assert.inc ["User foo is altered on node_2"]
# connection node_3
include/assert.inc ["User foo is altered on node_3"]
#
# Test galera.acct.mgmt.1.3 : ALTER USER
#
# connection node_2
include/assert.inc ["User foo is not expired on node_2"]
USE db;
ALTER USER "foo"@"%" PASSWORD EXPIRE;
include/assert.inc ["User foo is expired on node_2"]
INSERT INTO db.counter(count) VALUES(107);
# connection node_3
include/assert.inc ["User foo is expired on node_3"]
#
# Test galera.acct.mgmt.1.4 : GRANT
#
# connection node_2
USE db;
GRANT SELECT ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(108);
include/assert.inc ["User foo has SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has SELECT access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.1.5 : REVOKE
#
# connection node_2
USE db;
REVOKE SELECT ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(109);
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.1.6 : GRANT ALL
#
# connection node_2
USE db;
GRANT ALL ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(110);
include/assert.inc ["User foo has ALL access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has ALL access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.1.7 : REVOKE ALL
#
# connection node_2
USE db;
REVOKE ALL ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(111);
include/assert.inc ["User foo has no access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has no access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.1.8 : DROP USER
#
# connection node_2
USE db;
DROP USER "foo"@"%";
INSERT INTO db.counter(count) VALUES(112);
include/assert.inc ["User foo is not on node_2"]
# connection node_3
include/assert.inc ["User foo is not on node_3"]
#
# Test galera.acct.mgmt.2.1 : CREATE USER
#
# connection node_2
USE dbx;
CREATE USER "foo"@"%" IDENTIFIED BY "bar";
INSERT INTO db.counter(count) VALUES(113);
include/assert.inc ["User foo is on node_2"]
# connection node_3
include/assert.inc ["User foo is on node_3"]
#
# Test galera.acct.mgmt.2.2 : CHANGE PASSWORD
#
# connection node_2
USE db;
SET PASSWORD FOR "foo"@"%" = "notapassword";
INSERT INTO db.counter(count) VALUES(114);
include/assert.inc ["User foo is altered on node_2"]
# connection node_3
include/assert.inc ["User foo is altered on node_3"]
#
# Test galera.acct.mgmt.2.3 : ALTER USER
#
# connection node_2
include/assert.inc ["User foo is not expired on node_2"]
USE dbx;
ALTER USER "foo"@"%" PASSWORD EXPIRE;
include/assert.inc ["User foo is expired on node_2"]
INSERT INTO db.counter(count) VALUES(115);
# connection node_3
include/assert.inc ["User foo is expired on node_3"]
#
# Test galera.acct.mgmt.2.4 : GRANT
#
# connection node_2
USE dbx;
GRANT SELECT ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(116);
include/assert.inc ["User foo has SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has SELECT access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.2.5 : REVOKE
#
# connection node_2
USE dbx;
REVOKE SELECT ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(117);
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo does not have SELECT access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.2.6 : GRANT ALL
#
# connection node_2
USE dbx;
GRANT ALL ON db1.t1 TO "foo"@"%";
INSERT INTO db.counter(count) VALUES(118);
include/assert.inc ["User foo has ALL access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo has ALL access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.2.7 : REVOKE ALL
#
# connection node_2
USE dbx;
REVOKE ALL ON db1.t1 FROM "foo"@"%";
INSERT INTO db.counter(count) VALUES(119);
include/assert.inc ["User foo does not have access on db1.t1 on node_2"]
# connection node_3
include/assert.inc ["User foo does not have access on db1.t1 on node_3"]
#
# Test galera.acct.mgmt.2.8 : DROP USER
#
# connection node_2
USE dbx;
DROP USER "foo"@"%";
INSERT INTO db.counter(count) VALUES(120);
include/assert.inc ["User foo is not on node_2"]
# connection node_3
include/assert.inc ["User foo is not on node_3"]
#
# galera.acct.mgmt test cleanup
#
# connection node_2
DROP DATABASE db1;
# connection node_3
include/assert.inc ['db1 is not on node_3']
#
# Overall cleanup
#
# connection node_2
STOP SLAVE;
RESET SLAVE ALL;
# connection node_1
RESET MASTER;
CHANGE MASTER TO MASTER_HOST='127.0.0.1' FOR CHANNEL 'wsrep';
ERROR HY000: CHANGE MASTER with the given parameters cannot be performed on channel 'wsrep'.
START SLAVE FOR CHANNEL 'wsrep';
ERROR HY000: START SLAVE FOR CHANNEL cannot be performed on channel 'wsrep'.
STOP SLAVE FOR CHANNEL 'wsrep';
ERROR HY000: STOP SLAVE FOR CHANNEL cannot be performed on channel 'wsrep'.
SHOW RELAYLOG EVENTS FOR CHANNEL 'wsrep';
ERROR HY000: SHOW RELAYLOG EVENTS cannot be performed on channel 'wsrep'.
FLUSH RELAY LOGS FOR CHANNEL 'wsrep';
ERROR HY000: FLUSH RELAY LOGS cannot be performed on channel 'wsrep'.
SHOW SLAVE STATUS FOR CHANNEL 'wsrep';
ERROR HY000: SHOW SLAVE STATUS cannot be performed on channel 'wsrep'.
RESET SLAVE FOR CHANNEL 'wsrep';
ERROR HY000: RESET SLAVE [ALL] FOR CHANNEL cannot be performed on channel 'wsrep'.
CHANGE REPLICATION FILTER REPLICATE_DO_DB=(db1) FOR CHANNEL 'wsrep';
ERROR HY000: CHANGE REPLICATION FILTER cannot be performed on channel 'wsrep'.
#node-2 (cluster node)
CHANGE MASTER TO MASTER_HOST='127.0.0.1' FOR CHANNEL 'wsrep';
ERROR HY000: CHANGE MASTER with the given parameters cannot be performed on channel 'wsrep'.
START SLAVE FOR CHANNEL 'wsrep';
ERROR HY000: START SLAVE FOR CHANNEL cannot be performed on channel 'wsrep'.
STOP SLAVE FOR CHANNEL 'wsrep';
ERROR HY000: STOP SLAVE FOR CHANNEL cannot be performed on channel 'wsrep'.
SHOW RELAYLOG EVENTS FOR CHANNEL 'wsrep';
ERROR HY000: SHOW RELAYLOG EVENTS cannot be performed on channel 'wsrep'.
FLUSH RELAY LOGS FOR CHANNEL 'wsrep';
ERROR HY000: FLUSH RELAY LOGS cannot be performed on channel 'wsrep'.
SHOW SLAVE STATUS FOR CHANNEL 'wsrep';
ERROR HY000: SHOW SLAVE STATUS cannot be performed on channel 'wsrep'.
RESET SLAVE FOR CHANNEL 'wsrep';
ERROR HY000: RESET SLAVE [ALL] FOR CHANNEL cannot be performed on channel 'wsrep'.
call mtr.add_suppression("Pending to replicate MySQL GTID event.*");
call mtr.add_suppression("Pending to replicate MySQL GTID event.*");
call mtr.add_suppression("Pending to replicate MySQL GTID event.*");
call mtr.add_suppression("FLUSH RELAY LOGS cannot be performed on channel 'wsrep'");
call mtr.add_suppression("Slave channel 'wsrep' does not exist");
