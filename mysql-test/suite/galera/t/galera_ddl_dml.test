
#
# This test exercises multiple scenario that involves testing
# different DDL + DML statement for innodb and myisam engine
#

--source include/galera_cluster.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc


#-------------------------------------------------------------------------------
#
# Test-Scenarios
#
# 1. DDL/DML statement and their replication
# 2. DDL/DML statement and their replication with enforce_storage_engine
#
#

#-------------------------------------------------------------------------------
#
# create test-bed
#
--let $wsrep_replicate_myisam_saved = `select @@wsrep_replicate_myisam`



#-------------------------------------------------------------------------------
#
# 1. DDL/DML statement and their replication
#
--connection node_1
--echo #node-1

create table t1 (i int) engine=innodb;
insert into t1 values (1), (2), (3);

set wsrep_replicate_myisam = 0;
create table t2 (j int) engine=myisam;
insert into t2 values (10), (20), (30);
set wsrep_replicate_myisam = 0;

set wsrep_replicate_myisam = 1;
create table t3 (j int) engine=myisam;
insert into t3 values (100), (200), (300);
set wsrep_replicate_myisam = 0;

create compression_dictionary numbers ('percona');
create table tdict (
	id int,
	a blob column_format compressed,
	b blob column_format compressed with compression_dictionary numbers,
	primary key pk(id)) engine=innodb;
insert into tdict values (
	1, repeat('percona is great company', 50),
	repeat('percona is great company', 50));


--connection node_2
--echo #node-2
show tables;
select * from t1;
select * from t2;
select * from t3;
show create table tdict;
--echo # ensure dictionary is created
select * from information_schema.compression_dictionary_tables where dict_name like '%number%';

--connection node_1
--echo #node-1
truncate table t1;
truncate table t2;
truncate table t3;

--connection node_2
--echo #node-2
show tables;
select * from t1;
select * from t2;
select * from t3;

--connection node_1
--echo #node-1
drop table t1;
drop table t2;
drop table t3;
drop table tdict;
drop compression_dictionary numbers;

--connection node_2
--echo #node-2
--echo # ensure dictionary drop is replicated
select * from information_schema.compression_dictionary_tables where dict_name like '%number%';

#-------------------------------------------------------------------------------
#
# 1. DDL/DML statement and their replication
#
--connection node_2
--echo #node-2
call mtr.add_suppression("Can't create database");


--connection node_1
--echo #node-1
#
--let $wsrep_debug_orig = `SELECT @@wsrep_debug`
set global wsrep_debug=1;
#
create table t (i int, primary key pk(i)) engine=innodb;
SET SESSION wsrep_sync_wait = 0;
SET DEBUG_SYNC = "pxc_in_commit_flush_stage SIGNAL entered1 WAIT_FOR continue1";
--send insert into t values (1);

--connect node_1b, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1b
--echo #node-1b
SET SESSION wsrep_sync_wait = 0;
# this loop needs to be done before the next create/ddl loop as
# create/ddl can conflict with the lock that this connection
# may take on test db (intention exclusive).

--connect node_1a, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1a
--echo #node-1a
SET SESSION wsrep_sync_wait = 0;
SET DEBUG_SYNC = "now WAIT_FOR entered1";
# starting 8.0, create db is blocking insert. (mdl locks).
--send create database test;

--connection node_1b
--echo #node-1b
SET DEBUG_SYNC = "now SIGNAL continue1";

--connection node_1a
--echo #node-1a
--error ER_DB_CREATE_EXISTS
--reap

--connection node_1
--echo #node-1
--reap
select * from t;
--eval SET GLOBAL wsrep_debug = $wsrep_debug_orig
SET DEBUG_SYNC = 'RESET';
drop table t;

#-------------------------------------------------------------------------------
#
# 2. Variation of test-case above where DML complete while DDL is process of
#    forcefully aborting it.
#
--connection node_2
--echo #node-2
call mtr.add_suppression("Can't create database");


--connection node_1
--echo #node-1
#
--let $wsrep_debug_orig = `SELECT @@wsrep_debug`
set global wsrep_debug=1;
#
create table t (i int, primary key pk(i)) engine=innodb;
SET SESSION wsrep_sync_wait = 0;
SET DEBUG_SYNC = "pxc_in_commit_flush_stage SIGNAL entered1 WAIT_FOR continue1";
--send insert into t values (1);

--connection node_1b
--echo #node-1b
SET SESSION wsrep_sync_wait = 0;
# this loop needs to be done before the next create/ddl loop as
# create/ddl can conflict with the lock that this connection
# may take on test db (intention exclusive).

--connect node_1c, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1c
--echo #node-1c
SET SESSION wsrep_sync_wait = 0;

--connection node_1a
--echo #node-1a
SET SESSION wsrep_sync_wait = 0;
SET DEBUG_SYNC = "now WAIT_FOR entered1";
# starting 8.0, create db is blocking insert. (mdl locks).
set DEBUG_SYNC = "pxc_add_ticket_trying_to_wait_for_victim SIGNAL entered2 WAIT_FOR continue2";
--send create database test;

--connection node_1b
--echo #node-1b
SET DEBUG_SYNC = "now WAIT_FOR entered2";
SET DEBUG_SYNC = "now SIGNAL continue1";

--connection node_1c
--echo #node-1c (while ddl is trying to abort dml, let dml complete)
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE STATE = 'closing tables' and INFO = 'insert into t values (1)';
--source include/wait_condition.inc
SET DEBUG_SYNC = "now SIGNAL continue2";

--connection node_1a
--echo #node-1a
--error ER_DB_CREATE_EXISTS
--reap

--connection node_1
--echo #node-1
--reap
select * from t;
--eval SET GLOBAL wsrep_debug = $wsrep_debug_orig
SET DEBUG_SYNC = 'RESET';
drop table t;

#-------------------------------------------------------------------------------
#
# remove test-bed
#
--eval set @@wsrep_replicate_myisam = $wsrep_replicate_myisam_saved;
SET DEBUG_SYNC = "reset";
