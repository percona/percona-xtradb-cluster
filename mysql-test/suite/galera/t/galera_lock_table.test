#
# Test that a LOCK TABLE on the slave will cause the applier thread to block,
# so no subsequent updates are replicated on the slave until UNLOCK TABLE
# is issued.
#

--source include/galera_cluster.inc
--source include/have_innodb.inc

CREATE TABLE t1 (id INT PRIMARY KEY) ENGINE=InnoDB;
CREATE TABLE t2 (id INT PRIMARY KEY) ENGINE=InnoDB;

--connection node_2
<<<<<<< HEAD
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 't2'
--source include/wait_condition.inc

||||||| merged common ancestors
=======
# Run selects with wsrep_sync_wait=DEFAULT to ensure that both tables
# were created no node_2 before moving further in the test.
SELECT COUNT(*) = 0 FROM t1;
SELECT COUNT(*) = 0 FROM t2;
>>>>>>> wsrep_5.7.36-25.28
LOCK TABLE t1 READ;

--connection node_1
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);

# We use a separate connection here so that we can SELECT from both tables
# without running into "table t2 was not locked" error.

--let $galera_connection_name = node_2a
--let $galera_server_number = 2
--source include/galera_connect.inc
--connection node_2a
# Wait that the appliers has hit metadata lock wait
SET SESSION wsrep_sync_wait = 0;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
--let $wait_condition = SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE USER = 'system user' AND STATE = 'Waiting for table metadata lock'
--source include/wait_condition.inc

SELECT COUNT(*) = 0 FROM t1;
SELECT COUNT(*) = 0 FROM t2;

--connection node_2
UNLOCK TABLES;

SET SESSION wsrep_sync_wait=DEFAULT;

SELECT COUNT(*) = 1 FROM t1;
SELECT COUNT(*) = 1 FROM t2;

DROP TABLE t1;
DROP TABLE t2;
